# 복셀 메시 생성과 절차적 텍스처

> 복셀 데이터를 렌더링 가능한 메시로 변환하는 전략과, 아트 에셋 없이 코드만으로 텍스처를 생성하는 기법을 다룹니다.

## 목차

- [복셀 메싱 전략](#복셀-메싱-전략)
- [Vertex Ambient Occlusion](#vertex-ambient-occlusion)
- [텍스처 아틀라스](#텍스처-아틀라스)
- [절차적 텍스처 생성](#절차적-텍스처-생성)
- [Normal Mapping](#normal-mapping)
- [참고 자료](#참고-자료)

---

## 복셀 메싱 전략

복셀 데이터는 3D 격자(grid)에 블록 타입이 저장된 배열입니다. 이를 GPU가 렌더링할 수 있는 삼각형 메시로 변환해야 합니다. 메싱 전략에 따라 생성되는 폴리곤 수와 성능이 크게 달라집니다.

### Naive Meshing

가장 단순한 접근입니다. 모든 비어있지 않은(non-air) 블록의 6면을 전부 삼각형으로 생성합니다.

```
블록 1개 = 6면 × 2삼각형 = 12삼각형
N개 블록 = 12N 삼각형
```

대부분의 면은 인접 블록에 가려져 보이지 않으므로, 생성되는 삼각형의 대다수가 낭비입니다. 16x128x16 청크에서 솔리드 블록이 절반이라고 가정하면 약 20만 개의 삼각형이 생성되지만, 실제로 보이는 것은 일부뿐입니다.

### Culled Face Meshing

**인접 블록이 불투명하면 그 면을 생략**합니다. 블록의 6면 각각에 대해 이웃 블록을 검사하고, 이웃이 솔리드(불투명)이면 어차피 보이지 않으므로 메시를 생성하지 않습니다.

```
면 생성 조건:
  이웃 블록이 AIR   → 면 생성 (보임)
  이웃 블록이 솔리드 → 면 생략 (가려짐)
```

이것만으로 삼각형 수가 보통 **85~95% 감소**합니다. 지형 내부의 모든 면이 제거되고 표면에 노출된 면만 남기 때문입니다. 대부분의 복셀 엔진이 최소한 이 수준의 최적화를 적용합니다.

#### 청크 경계 문제

청크 경계에서의 면 컬링에는 주의가 필요합니다. 청크 가장자리의 블록은 인접 블록이 **다른 청크**에 속하므로, 이웃 청크의 데이터를 참조해야 합니다.

```
                청크 A              청크 B
           ┌──────────────┐   ┌──────────────┐
           │           [X]│   │[Y]           │
           └──────────────┘   └──────────────┘
                          ↑   ↑
                    X의 동쪽 면을 컬링하려면
                    Y(다른 청크)를 확인해야 함
```

이웃 청크 정보 없이 컬링하면 청크 경계에 불필요한 면이 남거나, 반대로 필요한 면이 사라질 수 있습니다.

#### 반투명/특수 블록 처리

단순 솔리드/에어 이분법으로는 부족한 경우:

- **반투명 블록** (물, 얼음): 솔리드이지만 뒤가 비쳐 보임 → 같은 타입끼리는 면 생략, 다른 타입 사이에는 면 생성
- **컷아웃 블록** (나뭇잎): 부분적으로 투명 → 인접한 솔리드 블록의 면도 생성해야 함
- **물 메시 분리**: 물은 별도의 렌더링 패스(반투명)가 필요하므로, 메시를 불투명/반투명으로 분리 생성

### Greedy Meshing

Culled Face 방식은 블록당 최대 4개 정점(1면)을 생성하지만, **인접한 동일 블록의 면들은 하나의 큰 사각형으로 병합**할 수 있습니다. 이것이 Greedy Meshing입니다.

```
Culled Face:                    Greedy:
┌─┬─┬─┬─┐                     ┌───────────┐
│ │ │ │ │  4개 쿼드             │           │  1개 쿼드
├─┼─┼─┼─┤  (16삼각형)          │           │  (2삼각형)
│ │ │ │ │                      │           │
└─┴─┴─┴─┘                     └───────────┘
```

원리:
1. 한 면 방향(예: 상단)의 모든 노출된 면을 2D 슬라이스로 추출
2. 슬라이스를 행(row) 단위로 스캔하며 **같은 블록 타입의 연속 구간**을 찾는다
3. 찾은 구간을 아래 행으로 확장 가능한지 검사 → 최대한 큰 직사각형으로 병합
4. 병합된 직사각형 하나가 하나의 쿼드(삼각형 2개)가 됨

Greedy meshing은 삼각형 수를 Culled 대비 **추가로 50~80% 감소**시킵니다. 단, 블록 타입이 다양하면 병합 기회가 줄고, 블록별 UV/텍스처 구분이 필요하면 병합 조건이 복잡해집니다.

### 메싱 전략 비교

| 전략 | 삼각형 수 | 장점 | 단점 |
|------|----------|------|------|
| **Naive** | 12N (전체 블록) | 가장 단순 | 대부분 낭비, 실용적이지 않음 |
| **Culled Face** | 표면 면만 | 구현 간단, 85~95% 감소 | 블록 단위 정점, Greedy보다는 많음 |
| **Greedy** | 병합된 쿼드 | 최소 삼각형, 최고 성능 | 복잡한 구현, UV/AO 처리 까다로움 |

Greedy meshing은 Vertex AO나 블록별 텍스처와 결합할 때 병합 조건에 제약이 생겨 구현 복잡도가 크게 올라갑니다. Culled Face 방식이 단순함과 성능의 좋은 균형점이 됩니다.

---

## Vertex Ambient Occlusion

### 개념

복셀의 모서리나 구석에서 주변광이 차폐되어 어둡게 보이는 현상을 **메시 생성 시점에 미리 계산**하는 기법입니다. SSAO 같은 스크린 공간 기법과 달리 정점(vertex) 속성으로 저장하므로 런타임 비용이 거의 없습니다.

### 계산 방법

각 면의 4개 정점에 대해, 해당 정점 주변의 인접 블록 3개(두 변 이웃 + 모서리 이웃)가 솔리드인지 검사합니다:

```
      ┌───┐
      │ C │ ← Corner (모서리 이웃)
  ┌───┼───┤
  │S1 │ V │ ← V = 현재 정점, S1/S2 = Side (변 이웃)
  ├───┼───┘
  │S2 │
  └───┘
```

- **Side 1, Side 2** = 정점에 인접한 두 변 방향의 블록
- **Corner** = 대각선 모서리의 블록

AO 레벨은 차폐된 이웃 수에 따라 결정됩니다:

| Side1 | Side2 | Corner | AO 레벨 | 밝기 |
|-------|-------|--------|---------|------|
| 없음 | 없음 | 없음 | 3 (밝음) | 1.0 |
| 1개 | 없음 | 없음 | 2 | 0.67 |
| 1개 | 없음 | 1개 | 1 | 0.33 |
| 1개 | 1개 | (무시) | 0 (어두움) | 0.0 |

**두 Side가 모두 차폐되면 Corner를 무시합니다.** 두 변 이웃이 모두 솔리드이면 모서리까지 갈 필요 없이 완전 차폐이기 때문입니다.

### AO-aware 삼각형 분할

하나의 쿼드(4정점)를 삼각형 2개로 나눌 때, **대각선 방향의 선택**이 AO 품질에 영향을 미칩니다.

```
방법 A (0-1-2, 0-2-3):       방법 B (0-1-3, 1-2-3):
  3───2                        3───2
  │ ╱ │                        │ ╲ │
  │╱  │                        │  ╲│
  0───1                        0───1
```

네 정점의 AO 값이 불균형일 때, 대각선을 어떻게 잡느냐에 따라 보간 결과가 달라집니다. **AO 합이 더 큰 대각선을 선택**하면 보간이 자연스러워지고, 체커보드 같은 아티팩트가 방지됩니다:

```
if (AO[0] + AO[2] > AO[1] + AO[3]):
    대각선 0-2 사용 (삼각형: 0-2-1, 0-3-2)
else:
    대각선 1-3 사용 (삼각형: 0-3-1, 1-3-2)
```

이 기법은 Coder Corner 블로그의 "Ambient Occlusion for Minecraft-like Worlds"에서 제안되었습니다.

---

## 텍스처 아틀라스

### 개념

텍스처 아틀라스(Texture Atlas)는 여러 개의 작은 텍스처를 하나의 큰 텍스처에 타일 형태로 배치한 것입니다. GPU에서 텍스처 바인딩을 교체하면 파이프라인 상태가 바뀌어 드로우 콜이 끊기는데, 아틀라스를 사용하면 UV 좌표만으로 원하는 타일을 참조할 수 있으므로 **모든 블록을 하나의 드로우 콜로 처리**할 수 있습니다.

### UV 매핑

블록 타입 번호로부터 아틀라스 내 타일의 UV 좌표를 계산합니다:

```
타일 크기 = 1 / 전체 타일 수 (정규화 좌표)

tileU = (blockType % tilesPerRow) × 타일 크기
tileV = floor(blockType / tilesPerRow) × 타일 크기

블록 면의 UV = (tileU, tileV) ~ (tileU + 타일 크기, tileV + 타일 크기)
```

면의 4개 정점에 `(0,0), (1,0), (1,1), (0,1)` 를 타일 범위로 스케일/오프셋하면 정확히 해당 블록의 텍스처 영역을 샘플링하게 됩니다.

### PBR 다중 아틀라스

PBR 렌더링에서는 색상 외에 재질 정보와 법선 정보가 추가로 필요합니다. 이를 위해 **같은 타일 레이아웃의 아틀라스를 여러 장** 생성합니다:

- **Albedo Atlas** — 표면 색상과 무늬
- **Material Atlas** — PBR 재질 파라미터 (roughness, metallic, emissive 등)
- **Normal Atlas** — 탄젠트 공간 법선 벡터

같은 UV로 3장을 동시에 샘플링하면 해당 블록의 색상, 재질, 법선을 한번에 얻습니다.

---

## 절차적 텍스처 생성

### 왜 절차적 생성인가?

외부 이미지 에셋 없이 코드만으로 텍스처를 만드는 접근입니다:

- **에셋 의존성 제거** — 이미지 파일 관리/로딩 불필요
- **무한 변형** — 파라미터 조정만으로 새로운 질감
- **일관된 스타일** — 같은 알고리즘 기반으로 모든 텍스처의 통일감 유지
- **경량** — 텍스처 파일 크기 0, 런타임에 생성

### 해시 기반 결정적 난수

절차적 패턴의 기본 빌딩 블록은 **정수 해시 함수**입니다.

```
h = hash(x, y, seed)    → [0, 1]
```

핵심 성질:
- **결정적(deterministic)** — 같은 입력은 항상 같은 출력. 패턴이 프레임마다 일관됨
- **독립적** — 시드를 바꾸면 상관없는 별도 패턴. 여러 레이어를 독립적으로 중첩 가능
- **빠름** — 정수 곱셈/시프트만으로 계산

Simplex/Perlin 같은 연속 노이즈와 달리, 해시는 **인접 픽셀간 상관관계가 없습니다**. 이 "거친" 특성이 오히려 돌 입자, 모래알, 나무 결의 미세한 불규칙성을 표현하는 데 적합합니다.

### 패턴 조합 기법

기본 색상(base color) 위에 다양한 변조를 레이어링하여 자연스러운 질감을 만듭니다:

| 기법 | 원리 | 표현 예시 |
|------|------|----------|
| **밝기 변동** | 픽셀별 해시 → 미세한 밝기 오프셋 | 입자감, 거친 돌 표면 |
| **주기 함수** | `sin(coord × freq)` | 사암 층리, 나무 껍질의 수직 줄무늬 |
| **동심원** | 중심까지 거리 + sin | 나무 단면의 나이테 |
| **셀 분할** | `coord % cellSize`의 경계 감지 | 조약돌 줄눈, 벽돌 모르타르 |
| **클러스터링** | 해시 중심점 + 맨해튼 거리 판정 | 광석 맥(vein) |
| **희소 변형** | `hash < threshold` 조건 분기 | 드문 밝은 반점, 균열, 이끼 |

하나의 블록에 여러 기법을 조합하는 예:

```
돌(Stone) = 기본 회색
  + 밝기 변동 (입자감)
  + 희소 조건 → 0.08 확률로 어두운 균열 반점
  + 희소 조건 → 0.08 확률로 밝은 광물 반점
```

### 재질 속성의 절차적 생성

Albedo(색상)뿐 아니라 PBR 재질 속성도 절차적으로 생성합니다. 같은 패턴 로직을 재질에도 적용하면 색상과 재질이 **공간적으로 일치**합니다:

- 광석 맥 위치에서 metallic 상승 (반짝이는 금속 광택)
- 용암 균열 부분에서 emissive 상승 (빛나는 갈라진 틈)
- 얼음 균열 부분에서 roughness 상승 (갈라진 곳만 거침)
- 같은 해시 시드를 공유하면 패턴이 정확히 겹침

### Height Map에서 Normal Map 유도

노멀 맵도 절차적으로 생성합니다. 단계:

1. 블록 타입별로 **height map**을 먼저 생성 (해시/패턴 함수로 각 픽셀의 높이 값)
2. 인접 픽셀과의 높이 차이를 **유한 차분(finite difference)**으로 미분
3. 기울기 벡터를 법선 벡터로 정규화

```
dx = height(x-1, y) - height(x+1, y)
dy = height(x, y-1) - height(x, y+1)
normal = normalize(dx × strength, dy × strength, 1.0)
```

**strength**가 클수록 요철이 과장되어 깊은 질감이 표현됩니다. 재질 특성에 따라 다른 강도를 사용합니다:

```
코블스톤 → 강한 요철 (거친 돌 표면)
모래     → 매우 약한 요철 (미세한 입자)
눈       → 거의 평탄 (부드러운 표면)
```

결과 법선은 **탄젠트 공간**(아래 설명)으로, `[-1, 1]` 범위를 `[0, 1]`로 인코딩하여 저장합니다:

```
encoded = normal × 0.5 + 0.5
```

평탄한 면 `(0, 0, 1)`은 `(0.5, 0.5, 1.0)` = 보라빛으로 인코딩됩니다. 이것이 노멀 맵 텍스처의 특징적인 보라색의 이유입니다.

---

## Normal Mapping

### 목적

복셀의 각 면은 기하학적으로 완벽한 평면입니다. 하지만 현실의 돌, 나무, 흙은 미세한 요철이 있고, 이 요철이 빛과 상호작용하여 질감을 만듭니다. 모든 요철을 실제 폴리곤으로 만들면 정점 수가 폭발하므로, **법선(normal) 벡터만 변조하여** 평면이 울퉁불퉁해 보이게 합니다.

핵심은 조명 계산이 **표면의 기하학적 형태가 아니라 법선 방향에만 의존**한다는 점입니다. 법선만 바꾸면 빛의 반사/산란 패턴이 바뀌어 평면도 거친 것처럼 보입니다.

### 탄젠트 공간 (Tangent Space)

노멀 맵의 법선은 **탄젠트 공간**이라는 로컬 좌표계에서 정의됩니다:

- **T (Tangent)**: 텍스처의 U 방향 (가로)
- **B (Bitangent)**: 텍스처의 V 방향 (세로)
- **N (Normal)**: 표면의 기하학적 법선 (위)

```
     N (법선)
     ↑
     │
     │
     ·───→ T (탄젠트)
    /
   ↙
  B (바이탄젠트)
```

탄젠트 공간에서 `(0, 0, 1)`은 "변조 없음 = 원래 면 방향 그대로"를 의미합니다.

탄젠트 공간을 사용하는 이유는 **같은 노멀 맵을 어떤 방향의 면에든 재사용**할 수 있기 때문입니다. 월드 공간으로 저장하면 면 방향이 바뀔 때마다 별도의 노멀 맵이 필요합니다.

### TBN 행렬

탄젠트 공간의 법선을 조명 계산에 사용하려면 **월드 공간**으로 변환해야 합니다. 이를 위한 것이 **TBN 행렬**입니다:

```
TBN = [T | B | N]     (3x3 행렬, 각 열이 T, B, N 벡터)

worldNormal = TBN × tangentNormal
```

일반 메시에서는 T, B를 정점 속성으로 저장하거나 UV에서 계산하지만, 복셀에서는 면이 항상 6방향(축 정렬) 중 하나이므로 **면 방향만으로 T, B, N이 고정적으로 결정**됩니다. 정점에 별도 저장할 필요 없이 면 인덱스 하나로 TBN을 구성할 수 있어 메모리와 대역폭이 절약됩니다.

---

## 참고 자료

### 복셀 메싱
- [0fps.net — Meshing in a Minecraft Game](https://0fps.net/2012/06/30/meshing-in-a-minecraft-game/) — Naive, Culled, Greedy 메싱 전략 비교와 성능 분석
- [0fps.net — Ambient Occlusion for Minecraft-like Worlds](https://web.archive.org/web/20230311043934/https://0fps.net/2013/07/03/ambient-occlusion-for-minecraft-like-worlds/) — Vertex AO 알고리즘과 AO-aware 삼각형 분할
- [Tomcc (Mojang) — Ambient Occlusion for Voxels](https://web.archive.org/web/20210429192144/https://tomcc.github.io/2014/08/31/visibility-1.html) — Minecraft 개발자의 복셀 가시성 및 AO 설명

### 텍스처 아틀라스
- [Wikipedia — Texture atlas](https://en.wikipedia.org/wiki/Texture_atlas) — 텍스처 아틀라스 개념과 게임 엔진에서의 활용
- [gamedevelopment.tutsplus.com — Texture Atlases](https://gamedevelopment.tutsplus.com/articles/tips-for-working-with-texture-atlases--cms-26498) — 아틀라스 패킹 전략과 UV 매핑

### 절차적 텍스처 생성
- [GPU Gems 1, Ch.26 — Implementing Improved Perlin Noise](https://developer.nvidia.com/gpugems/gpugems/part-iv-texturing/chapter-26-implementing-improved-perlin-noise) — GPU 기반 절차적 텍스처 생성
- [Inigo Quilez — Hash Functions for GPU Rendering](https://www.shadertoy.com/view/4djSRW) — 절차적 패턴에 사용되는 해시 함수 모음과 시각적 비교

### Normal Mapping
- [LearnOpenGL — Normal Mapping](https://learnopengl.com/Advanced-Lighting/Normal-Mapping) — 탄젠트 공간, TBN 행렬, 노멀 맵 적용의 시각적 설명
- [Wikipedia — Normal mapping](https://en.wikipedia.org/wiki/Normal_mapping) — 기법 개요와 역사
